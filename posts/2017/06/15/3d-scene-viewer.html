<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>3D Scene Viewer</title>
  <meta name="description" content="Changing topics, I will now discuss building a 3-D Scene Viewer i.e a tool to view a scene of 3D objects with features like support for multiple lights (poin...">

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="http://localhost:4000/2017/06/15/3d-scene-viewer.html">
  <link rel="alternate" type="application/rss+xml" title="Sridhar Mocherla" href="/feed.xml">
  
  
</head>


  <body>

    <header class="site-header" role="banner">

  <div class="wrapper">
    
    
    <a class="site-title" href="/">Sridhar Mocherla</a>
  
    
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
          
            
            
            <a class="page-link" href="/assets/resume.pdf">Resume</a>
            
          
            
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">3D Scene Viewer</h1>
    <p class="post-meta">
      <time datetime="2017-06-15T00:00:00-07:00" itemprop="datePublished">
        
        Jun 15, 2017
      </time>
      </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Changing topics, I will now discuss building a 3-D Scene Viewer i.e a tool to view a scene of 3D objects with features like support for multiple lights (point/directional/spot) using Blinn-Phong/Toon model, texture mapping (diffuse texture maps) and camera controls. All of this is established using <a href="https://www.opengl.org/">OpenGL (rendering)</a>, <a href="http://www.glfw.org/">GLFW (windowing system, wrapper around OpenGL)</a>, <a href="http://glm.g-truc.net/0.9.8/index.html">GLM (Coordinate transformations)</a>, <a href="https://github.com/skaslev/gl3w">gl3w (GL Core Profile support)</a> and <a href="http://www.lonesock.net/soil.html">SOIL (for loading textures)</a>.</p>

<p>I will divide the post into 4 sections - Scene file, Transformations, a section summarizing other features like lighting and texture mapping and final section on rendering.</p>

<h2 id="scene-file">Scene File</h2>
<p>We use a custom scene file format to describe all the components in a scene - objects, camera, lights, texture maps etc. The file format is as below:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>View section: keyword view
eye &lt;vec3&gt;
center &lt;vec3&gt;
viewup &lt;vec3&gt;
Lights section: keyword light
type [local|spot|directional]
ambient &lt;vec3&gt;
color &lt;vec3&gt;
position &lt;vec3&gt;
constAtt &lt;float&gt;
linearAtt &lt;float&gt;
quadAtt &lt;float&gt;
coneDirection &lt;vec3&gt;
spotCosCutoff &lt;vec3&gt;
spotExponent &lt;vec3&gt;
Objects section:
object &lt;filename of Wavefront OBJ file&gt;
shader [Blinn_Phong|Toon]
[
rx &lt;angle (degrees)&gt; ry &lt;angle (degrees)&gt; rz &lt;angle (degrees)&gt;
t &lt;vec3&gt;
s &lt;vec3&gt;
]
</code></pre>
</div>

<p>The view section describes the eye (camera position), center (the vector representing the focus of the camera) and viewup (vector representing vertical direction).  These are needed for transformation of the objects and will affect how they are viewed. The lights section describe one or more lights, their positions and properties which fit into the lighting models. The objects section should include one more objects with path to .obj files, associated shader followed by the set of transformations (Rotation/Translation/Scale) for each object.</p>

<p>In terms of code, this involves writing a parser to read all these sections which translates into the below abstraction:</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Object</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">string</span> <span class="n">path</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="n">rz</span><span class="p">;</span>
	<span class="n">vec3</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">string</span> <span class="n">shader</span><span class="p">;</span>
	<span class="n">mat4</span> <span class="n">modelingMatrix</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">Scene</span>
<span class="p">{</span>
	<span class="k">public</span><span class="o">:</span>
		
		<span class="n">lightProperties</span> <span class="n">lightVals</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">//upto 4 light sources supported
</span>		
		<span class="n">vec3</span> <span class="n">eye</span><span class="p">;</span>
		<span class="n">vec3</span> <span class="n">center</span><span class="p">;</span>
		<span class="n">vec3</span> <span class="n">viewUp</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">numLightSources</span><span class="p">;</span>
		<span class="n">vector</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">objects</span><span class="p">;</span>
		<span class="n">Scene</span><span class="p">();</span>

<span class="p">};</span>

<span class="k">class</span> <span class="nc">SceneParser</span>
<span class="p">{</span>
	<span class="k">public</span><span class="o">:</span>
		<span class="n">Scene</span> <span class="n">parseSceneFile</span><span class="p">(</span><span class="n">string</span> <span class="n">fileName</span><span class="p">);</span>
<span class="p">};</span>
</code></pre>
</div>

<h2 id="transformations">Transformations</h2>
<p>Each object exists in its unique coordinate space. So they have to be <em>transformed</em> to the camera’s coordinate space (<strong>Viewing transformation</strong>). The object might also have transformation with respect to its own coordinate space (<strong>Modeling transformation</strong>). And the final transformation involves transformation from the camera space to fit the camera’s frustum volume(<strong>Projection</strong>).  The viewport transformation is performed under-the-hood by the OpenGL to fit the objects within the screen space. These transformations can be visually illustrated with the below figure (courtesy of the OpenGL Redbook)</p>

<p><img src="http://res.cloudinary.com/dqagjb1nc/image/upload/v1497597941/Capture_gymr6m.png" alt="Transformations" /></p>

<p>Much of the transformations is performed using <strong>GLM</strong> which offers a powerful interface for storing coordinates and transforming them. The key transformation methods in OpenGL are <code class="highlighter-rouge">frustum()</code> for perspective projection, <code class="highlighter-rouge">ortho()</code> for orthogonal projection, <code class="highlighter-rouge">lookAt()</code> for viewing transformation and <code class="highlighter-rouge">rotate()</code>,<code class="highlighter-rouge">scale()</code> and <code class="highlighter-rouge">translate()</code> for the modeling transformations. The <a href="https://glm.g-truc.net/0.9.2/api/a00245.html">GLM docs</a> provide more context.</p>

<h2 id="lighting-shading-texture-mappingetc">Lighting, Shading, Texture Mapping…etc.</h2>
<p>This part involves key features of OpenGL from version 3.1 onwards when the <a href="https://www.khronos.org/opengl/wiki/Fixed_Function_Pipeline">Fixed Function Pipeline</a> was deprecated and the concept of <strong>shaders</strong> took importance. A shader is piece of C++ -like code but compiled, linked and runs completely on the GPU.  The language is called GLSL (GL Shading Language). Data is typically passed to shaders from CPU code using read-only variables called <strong>uniform</strong> variables. There are many types of shaders but two of them are mandatory - Vertex Shader (transformations on vertices to form primitives) and Fragment Shader (assigning color for fragments formed by primitives). There are other optional intermediate shaders like Geometry Shader and Tesellation shader which we do not discuss in this post. Below image (courtesy <a href="http://www.ntu.edu.sg/home/ehchua/programming/opengl/cg_basicstheory.html">this</a>) illustrates the basic shader pipeline.</p>

<p><img src="http://www.ntu.edu.sg/home/ehchua/programming/opengl/images/Graphics3D_Pipe.png" alt="OpenGL pipeline" /></p>

<p>In our accomodate, we perform the transformations (using the matrices) per vertex in the vertex shader and apply the lighting model in the fragment shader. A simple vertex shader looks something like this:</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Vertex shader for multiple lights stays the same with all lighting
// done in the fragment shader.
</span>
<span class="cp">#version 410 core
</span>
<span class="n">uniform</span> <span class="n">mat4</span> <span class="n">MVPMatrix</span><span class="p">;</span>	<span class="c1">// full model-view-projection matrix
</span><span class="n">uniform</span> <span class="n">mat4</span> <span class="n">MVMatrix</span><span class="p">;</span>	<span class="c1">// model and view matrix
</span><span class="n">uniform</span> <span class="n">mat3</span> <span class="n">NormalMatrix</span><span class="p">;</span>	<span class="c1">// transformation matrix for normals to eye coordinates
</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">VertexPosition</span><span class="p">;</span> <span class="c1">// Vertex Buffer Object pointing to the object positions
</span><span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec3</span> <span class="n">VertexNormal</span><span class="p">;</span>  <span class="c1">//Vertex Buffer Object pointing to normals at each position
</span><span class="n">layout</span><span class="p">(</span><span class="n">location</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="n">in</span> <span class="n">vec2</span> <span class="n">texIndex</span><span class="p">;</span> <span class="c1">//Vertex Buffer Object with texture map indices for each position
</span>
<span class="n">out</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>	<span class="c1">// vertex normal in eye coordinates
</span><span class="n">out</span> <span class="n">vec4</span> <span class="n">Position</span><span class="p">;</span>	<span class="c1">// vertex position in eye coordinates
</span><span class="n">out</span> <span class="n">vec2</span> <span class="n">textCoord</span><span class="p">;</span> <span class="c1">//pass texture map indices to frag shader
</span>
<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">textCoord</span> <span class="o">=</span><span class="n">vec2</span><span class="p">(</span><span class="n">texIndex</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="mf">1.0</span><span class="o">-</span><span class="n">texIndex</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="n">Normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">NormalMatrix</span> <span class="o">*</span> <span class="n">VertexNormal</span><span class="p">);</span>
    <span class="n">Position</span> <span class="o">=</span> <span class="n">MVMatrix</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">VertexPosition</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
    <span class="n">gl_Position</span> <span class="o">=</span> <span class="n">MVPMatrix</span> <span class="o">*</span> <span class="n">vec4</span><span class="p">(</span><span class="n">VertexPosition</span><span class="p">,</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>
<p>All shaders should have a <code class="highlighter-rouge">void main()</code> method. The transformation matrices are passed as uniform variables. The normal matrix is required for transforming normals at each object position to camera space and then utilized in the lighting model.</p>

<p>We implement two sets of shaders for two different lighting models - Blinn Phong model and Toon shader. The Blinn-Phong model is based on the below equation:</p>

<p><script type="math/tex">Intensity (I) = I_{ambient}*K_{ambient}</script> + <script type="math/tex">I_{directional}*K_{directional}*(N.L_p)</script> + <script type="math/tex">I_{specular}*K_{specular}*(N.L_p)^n</script></p>

<p>3 different components of each light source are incorporated and the <script type="math/tex">K</script> values are the surface coefficients for each component and are defined in a <strong>.mtl</strong>(material) file. <script type="math/tex">N</script> denotes the normal vector and <script type="math/tex">L_p</script> denotes the light position. The specular component indicates the highlights created by reflection and <script type="math/tex">n</script> denotes how sharp these highlights are.</p>

<p>The Toon shader creates cartoonish shades to the surface. This is done by discretizing color values based on light intensity values. The code for it (Fragment shader) is fairly straightforward</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="c1">// Toon Fragment shader for multiple lights.
</span>
<span class="cp">#version 410 core
</span>
<span class="n">in</span> <span class="n">vec2</span> <span class="n">textCoord</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">LightProperties</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">isEnabled</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">isLocal</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">isSpot</span><span class="p">;</span>
    <span class="n">vec3</span> <span class="n">ambient</span><span class="p">;</span>
    <span class="n">vec3</span> <span class="n">color</span><span class="p">;</span>
    <span class="n">vec3</span> <span class="n">position</span><span class="p">;</span>
    <span class="n">vec3</span> <span class="n">halfVector</span><span class="p">;</span>
    <span class="n">vec3</span> <span class="n">coneDirection</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">spotCosCutoff</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">spotExponent</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">constantAttenuation</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">linearAttenuation</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">quadraticAttenuation</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// the set of lights to apply, per invocation of this shader
</span><span class="k">const</span> <span class="kt">int</span> <span class="n">MAXLIGHTS</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">uniform</span> <span class="n">LightProperties</span> <span class="n">Lights</span><span class="p">[</span><span class="n">MAXLIGHTS</span><span class="p">];</span>

<span class="c1">// material description
</span><span class="n">uniform</span> <span class="n">vec3</span> <span class="n">ambient</span><span class="p">;</span>	
<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">diffuse</span><span class="p">;</span>
<span class="n">uniform</span> <span class="n">vec3</span> <span class="n">specular</span><span class="p">;</span>
<span class="n">uniform</span> <span class="kt">float</span> <span class="n">shininess</span><span class="p">;</span>
<span class="n">uniform</span> <span class="kt">bool</span> <span class="n">textureEnabled</span><span class="p">;</span>

<span class="n">uniform</span> <span class="n">sampler2D</span> <span class="n">textVar</span><span class="p">;</span> <span class="c1">// for texture mapping
</span>
<span class="n">in</span> <span class="n">vec3</span> <span class="n">Normal</span><span class="p">;</span>		<span class="c1">// normal in eye coordinates
</span><span class="n">in</span> <span class="n">vec4</span> <span class="n">Position</span><span class="p">;</span>	<span class="c1">// vertex position in eye coordinates
</span>
<span class="n">out</span> <span class="n">vec4</span> <span class="n">FragColor</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">vec3</span> <span class="n">scatteredLight</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">);</span>
	<span class="n">vec3</span> <span class="n">reflectedLight</span> <span class="o">=</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">0.</span><span class="n">f</span><span class="p">);</span>
	<span class="n">vec3</span> <span class="n">eyeDirection</span><span class="p">;</span>
	<span class="n">vec3</span> <span class="n">lightDirection</span><span class="p">;</span>
	<span class="n">vec3</span> <span class="n">halfVector</span><span class="p">;</span>
	<span class="n">vec3</span> <span class="n">myNormal</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span><span class="n">f</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">diffuseIntensity</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">specularCoeff</span><span class="p">;</span>

    <span class="c1">// loop over all the lights
</span>     

        <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>

        <span class="n">eyeDirection</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="o">-</span><span class="n">vec3</span><span class="p">(</span><span class="n">Position</span><span class="p">));</span>	<span class="c1">// since we are in eye coordinates
</span>													<span class="c1">// eye position is 0,0,0
</span>        <span class="c1">// for local lights, compute per-fragment direction,
</span>        <span class="c1">// halfVector, and attenuation
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">Lights</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">isLocal</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> 
		   <span class="p">{</span>
		        <span class="n">lightDirection</span> <span class="o">=</span> <span class="n">Lights</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">position</span> <span class="o">-</span> <span class="n">vec3</span><span class="p">(</span><span class="n">Position</span><span class="p">);</span>
            <span class="kt">float</span> <span class="n">lightDistance</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">lightDirection</span><span class="p">);</span>
            <span class="n">lightDirection</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightDirection</span><span class="p">);</span>

			
			    	<span class="k">if</span> <span class="p">(</span><span class="n">Lights</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">isSpot</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> 
				    <span class="p">{</span>
				         	<span class="n">vec3</span> <span class="n">myConeDirection</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Lights</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">coneDirection</span><span class="p">);</span>
					        <span class="kt">float</span> <span class="n">spotCos</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">lightDirection</span><span class="p">,</span><span class="o">-</span><span class="n">myConeDirection</span><span class="p">);</span>
					
				    <span class="p">}</span>
            <span class="n">halfVector</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightDirection</span> <span class="o">+</span> <span class="n">eyeDirection</span><span class="p">);</span>
        <span class="p">}</span> 
		   <span class="k">else</span>
		   <span class="c1">// directional light
</span>		   <span class="p">{</span>
		      	<span class="n">lightDirection</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Lights</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">position</span><span class="p">);</span>
		      	<span class="n">halfVector</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">lightDirection</span> <span class="o">+</span> <span class="n">eyeDirection</span><span class="p">);</span>
        <span class="p">}</span>

		   <span class="n">myNormal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">Normal</span><span class="p">);</span>

       <span class="n">diffuseIntensity</span>  <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">myNormal</span><span class="p">,</span> <span class="n">lightDirection</span><span class="p">));</span>
       
		<span class="k">if</span><span class="p">(</span><span class="n">diffuseIntensity</span> <span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">diffuseIntensity</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">)</span>
			<span class="n">diffuseIntensity</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">diffuseIntensity</span> <span class="o">&gt;=</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">7.0</span> <span class="o">&amp;&amp;</span> <span class="n">diffuseIntensity</span> <span class="o">&lt;</span> <span class="mf">2.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">)</span>
			<span class="n">diffuseIntensity</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">diffuseIntensity</span> <span class="o">&gt;=</span> <span class="mf">2.0</span><span class="o">/</span><span class="mf">7.0</span> <span class="o">&amp;&amp;</span> <span class="n">diffuseIntensity</span> <span class="o">&lt;</span> <span class="mf">3.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">)</span>
			<span class="n">diffuseIntensity</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">diffuseIntensity</span> <span class="o">&gt;=</span> <span class="mf">3.0</span><span class="o">/</span><span class="mf">7.0</span> <span class="o">&amp;&amp;</span> <span class="n">diffuseIntensity</span> <span class="o">&lt;</span> <span class="mf">4.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">)</span>
			<span class="n">diffuseIntensity</span> <span class="o">=</span> <span class="mf">3.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">diffuseIntensity</span> <span class="o">&gt;=</span> <span class="mf">4.0</span><span class="o">/</span><span class="mf">7.0</span> <span class="o">&amp;&amp;</span> <span class="n">diffuseIntensity</span> <span class="o">&lt;</span> <span class="mf">5.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">)</span>
			<span class="n">diffuseIntensity</span> <span class="o">=</span> <span class="mf">4.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">diffuseIntensity</span> <span class="o">&gt;=</span> <span class="mf">5.0</span><span class="o">/</span><span class="mf">7.0</span> <span class="o">&amp;&amp;</span> <span class="n">diffuseIntensity</span> <span class="o">&lt;</span> <span class="mf">6.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">)</span>
			<span class="n">diffuseIntensity</span> <span class="o">=</span> <span class="mf">5.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">;</span>
		<span class="k">if</span><span class="p">(</span><span class="n">diffuseIntensity</span> <span class="o">&gt;=</span> <span class="mf">6.0</span><span class="o">/</span><span class="mf">7.0</span> <span class="o">&amp;&amp;</span> <span class="n">diffuseIntensity</span> <span class="o">&lt;</span> <span class="mf">7.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">)</span>
			<span class="n">diffuseIntensity</span> <span class="o">=</span> <span class="mf">6.0</span><span class="o">/</span><span class="mf">7.0</span><span class="p">;</span>
		
		<span class="c1">// Accumulate all the lights’ effects as it interacts with material properties
</span>
		<span class="n">scatteredLight</span> <span class="o">+=</span> <span class="n">Lights</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">color</span> <span class="o">*</span> <span class="n">ambient</span>  <span class="o">+</span> <span class="n">Lights</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">color</span> <span class="o">*</span> <span class="p">(</span><span class="n">diffuseIntensity</span><span class="o">*</span> <span class="n">diffuse</span><span class="p">)</span> <span class="p">;</span>  <span class="c1">//only 1st light used
</span>
	<span class="n">vec3</span> <span class="n">rgb</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">scatteredLight</span><span class="p">,</span> <span class="n">vec3</span><span class="p">(</span><span class="mf">1.0</span><span class="p">));</span>
	<span class="n">FragColor</span> <span class="o">=</span> <span class="n">vec4</span><span class="p">(</span><span class="n">rgb</span><span class="p">,</span><span class="mf">1.0</span><span class="n">f</span><span class="p">);</span> <span class="c1">//final color
</span><span class="p">}</span>
</code></pre>
</div>
<p>And finally texture mapping is implemented by loading static images and using the texture <em>samplers</em> in the fragment shader to sample the color at <script type="math/tex">(u,v)</script>. In terms of code, we would have something like below using <em>SOIL</em>:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">int</span> <span class="n">channels</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span> <span class="n">image</span> <span class="o">=</span> 	<span class="n">SOIL_load_image</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">width</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">height</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">channels</span><span class="p">,</span> <span class="n">SOIL_LOAD_AUTO</span><span class="p">);</span>
<span class="n">glEnable</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">bump</span><span class="p">)</span> <span class="c1">//if bump map
</span>	<span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span> <span class="o">+</span> <span class="n">obj</span><span class="p">.</span><span class="n">bumpMapTexID</span><span class="p">);</span>
<span class="k">else</span>
	<span class="n">glActiveTexture</span><span class="p">(</span><span class="n">GL_TEXTURE0</span> <span class="o">+</span> <span class="n">obj</span><span class="p">.</span><span class="n">diffuseTexMapID</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">text</span><span class="p">;</span> <span class="c1">//texture ID
</span><span class="n">glGetIntegerv</span><span class="p">(</span><span class="n">GL_ACTIVE_TEXTURE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">text</span><span class="p">);</span>
<span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">texture</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_S</span><span class="p">,</span> <span class="n">GL_REPEAT</span><span class="p">);</span>  <span class="c1">//wrap around object
</span><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_WRAP_T</span><span class="p">,</span> <span class="n">GL_REPEAT</span><span class="p">);</span>
<span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MAG_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span> <span class="c1">//linear interpolation for zooming
</span><span class="n">glTexParameteri</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">GL_TEXTURE_MIN_FILTER</span><span class="p">,</span> <span class="n">GL_LINEAR</span><span class="p">);</span>
	
<span class="c1">// store in framebuffer
</span><span class="k">if</span> <span class="p">(</span><span class="n">channels</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
	<span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGB</span><span class="p">,</span><span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">image</span><span class="p">);</span>
<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">channels</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">glTexImage2D</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GL_RGBA</span><span class="p">,</span> <span class="n">GL_UNSIGNED_BYTE</span><span class="p">,</span> <span class="n">image</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SOIL_free_image_data</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>
</code></pre>
</div>

<p>As we’ve seen in the fragment, a <script type="math/tex">sampler2D</script> type is used for sampling color using <script type="math/tex">(u,v)</script> indices.</p>

<p>Apart from that, to support viewing around the scene using keyboard controls(W,A,S,D,X,Y), we set GLFW keyboard callbacks by using the methods below:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>glfwSetKeyCallback(window, key_callback);
glfwSetWindowSizeCallback(window, resize);
</code></pre>
</div>

<h2 id="rendering">Rendering</h2>
<p>Each object has two aspects in the code - a <strong>Vertex Array Object (VAO)</strong> and three <strong>Vertex Buffer Objects (VBO)</strong>. A VAO is a handle or pointer to the VBOs. VBOs can store vertex data (position,normal,color,texture indices). We use 3 VBOs per object to store position, normals and texture map indices. Data is buffered to GPU using VBOs and VBOs are indexed in the shaders using <script type="math/tex">location</script> variable to dereference buffers. Drawing a object involves a sequence of calls <em>selecting</em> the shader,<em>binding</em> the vertex array object,<em>binding</em> the VBOs and then invoking a call to <code class="highlighter-rouge">glDrawArrays</code>.</p>
<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">glUseProgram</span><span class="p">(</span><span class="n">currentShader</span><span class="p">);</span>
<span class="p">....</span>
<span class="p">...</span>
<span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">VAO</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">...</span>
<span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">VAOsize</span><span class="p">);</span> <span class="c1">//draw as triangles
</span></code></pre>
</div>

<h2 id="a-few-scenes">A Few Scenes</h2>
<p><img src="https://res.cloudinary.com/dqagjb1nc/image/upload/v1497603703/Capture_plsuz9.png" alt="Random scene" /></p>

<p><img src="https://res.cloudinary.com/dqagjb1nc/image/upload/v1497605271/Capture_omtcjz.png" alt="Spot light" /></p>

<p><img src="https://res.cloudinary.com/dqagjb1nc/image/upload/v1497605675/Capture_rracnd.png" alt="Directional lights" /></p>

<p><a href="https://github.com/srmocher/3D-Viewer">Source</a></p>

  </div>

  
</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Sridhar Mocherla</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li>
            
              Sridhar Mocherla
            
            </li>
            
            <li><a href="mailto:srmocher@email.arizona.edu">srmocher@email.arizona.edu</a></li>
            
        </ul>
      </div>

      <div class="footer-col footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/srmocher"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">srmocher</span></a>

          </li>
          

          
          <li>
            <a href="https://twitter.com/sridharmocherla"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">sridharmocherla</span></a>

          </li>
          
        </ul>
      </div>

      <div class="footer-col footer-col-3">
        <p>A profile of my academic projects, work experience and my brief thoughts on computer science problems. Website under construction
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
